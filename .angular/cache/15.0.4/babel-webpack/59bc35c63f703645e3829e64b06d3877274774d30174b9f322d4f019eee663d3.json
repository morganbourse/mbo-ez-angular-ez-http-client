{"ast":null,"code":"import { Subscriber } from '../Subscriber';\nimport { EmptyError } from '../util/EmptyError';\nexport function single(predicate) {\n  return source => source.lift(new SingleOperator(predicate, source));\n}\n\nclass SingleOperator {\n  constructor(predicate, source) {\n    this.predicate = predicate;\n    this.source = source;\n  }\n\n  call(subscriber, source) {\n    return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));\n  }\n\n}\n\nclass SingleSubscriber extends Subscriber {\n  constructor(destination, predicate, source) {\n    super(destination);\n    this.predicate = predicate;\n    this.source = source;\n    this.seenValue = false;\n    this.index = 0;\n  }\n\n  applySingleValue(value) {\n    if (this.seenValue) {\n      this.destination.error('Sequence contains more than one element');\n    } else {\n      this.seenValue = true;\n      this.singleValue = value;\n    }\n  }\n\n  _next(value) {\n    const index = this.index++;\n\n    if (this.predicate) {\n      this.tryNext(value, index);\n    } else {\n      this.applySingleValue(value);\n    }\n  }\n\n  tryNext(value, index) {\n    try {\n      if (this.predicate(value, index, this.source)) {\n        this.applySingleValue(value);\n      }\n    } catch (err) {\n      this.destination.error(err);\n    }\n  }\n\n  _complete() {\n    const destination = this.destination;\n\n    if (this.index > 0) {\n      destination.next(this.seenValue ? this.singleValue : undefined);\n      destination.complete();\n    } else {\n      destination.error(new EmptyError());\n    }\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Morgan/Desktop/DEV/angular/mbo-ez-angular-ez-http-client/node_modules/rxjs/_esm2015/internal/operators/single.js"],"names":["Subscriber","EmptyError","single","predicate","source","lift","SingleOperator","constructor","call","subscriber","subscribe","SingleSubscriber","destination","seenValue","index","applySingleValue","value","error","singleValue","_next","tryNext","err","_complete","next","undefined","complete"],"mappings":"AAAA,SAASA,UAAT,QAA2B,eAA3B;AACA,SAASC,UAAT,QAA2B,oBAA3B;AACA,OAAO,SAASC,MAAT,CAAgBC,SAAhB,EAA2B;AAC9B,SAAQC,MAAD,IAAYA,MAAM,CAACC,IAAP,CAAY,IAAIC,cAAJ,CAAmBH,SAAnB,EAA8BC,MAA9B,CAAZ,CAAnB;AACH;;AACD,MAAME,cAAN,CAAqB;AACjBC,EAAAA,WAAW,CAACJ,SAAD,EAAYC,MAAZ,EAAoB;AAC3B,SAAKD,SAAL,GAAiBA,SAAjB;AACA,SAAKC,MAAL,GAAcA,MAAd;AACH;;AACDI,EAAAA,IAAI,CAACC,UAAD,EAAaL,MAAb,EAAqB;AACrB,WAAOA,MAAM,CAACM,SAAP,CAAiB,IAAIC,gBAAJ,CAAqBF,UAArB,EAAiC,KAAKN,SAAtC,EAAiD,KAAKC,MAAtD,CAAjB,CAAP;AACH;;AAPgB;;AASrB,MAAMO,gBAAN,SAA+BX,UAA/B,CAA0C;AACtCO,EAAAA,WAAW,CAACK,WAAD,EAAcT,SAAd,EAAyBC,MAAzB,EAAiC;AACxC,UAAMQ,WAAN;AACA,SAAKT,SAAL,GAAiBA,SAAjB;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKS,SAAL,GAAiB,KAAjB;AACA,SAAKC,KAAL,GAAa,CAAb;AACH;;AACDC,EAAAA,gBAAgB,CAACC,KAAD,EAAQ;AACpB,QAAI,KAAKH,SAAT,EAAoB;AAChB,WAAKD,WAAL,CAAiBK,KAAjB,CAAuB,yCAAvB;AACH,KAFD,MAGK;AACD,WAAKJ,SAAL,GAAiB,IAAjB;AACA,WAAKK,WAAL,GAAmBF,KAAnB;AACH;AACJ;;AACDG,EAAAA,KAAK,CAACH,KAAD,EAAQ;AACT,UAAMF,KAAK,GAAG,KAAKA,KAAL,EAAd;;AACA,QAAI,KAAKX,SAAT,EAAoB;AAChB,WAAKiB,OAAL,CAAaJ,KAAb,EAAoBF,KAApB;AACH,KAFD,MAGK;AACD,WAAKC,gBAAL,CAAsBC,KAAtB;AACH;AACJ;;AACDI,EAAAA,OAAO,CAACJ,KAAD,EAAQF,KAAR,EAAe;AAClB,QAAI;AACA,UAAI,KAAKX,SAAL,CAAea,KAAf,EAAsBF,KAAtB,EAA6B,KAAKV,MAAlC,CAAJ,EAA+C;AAC3C,aAAKW,gBAAL,CAAsBC,KAAtB;AACH;AACJ,KAJD,CAKA,OAAOK,GAAP,EAAY;AACR,WAAKT,WAAL,CAAiBK,KAAjB,CAAuBI,GAAvB;AACH;AACJ;;AACDC,EAAAA,SAAS,GAAG;AACR,UAAMV,WAAW,GAAG,KAAKA,WAAzB;;AACA,QAAI,KAAKE,KAAL,GAAa,CAAjB,EAAoB;AAChBF,MAAAA,WAAW,CAACW,IAAZ,CAAiB,KAAKV,SAAL,GAAiB,KAAKK,WAAtB,GAAoCM,SAArD;AACAZ,MAAAA,WAAW,CAACa,QAAZ;AACH,KAHD,MAIK;AACDb,MAAAA,WAAW,CAACK,KAAZ,CAAkB,IAAIhB,UAAJ,EAAlB;AACH;AACJ;;AA7CqC","sourcesContent":["import { Subscriber } from '../Subscriber';\nimport { EmptyError } from '../util/EmptyError';\nexport function single(predicate) {\n    return (source) => source.lift(new SingleOperator(predicate, source));\n}\nclass SingleOperator {\n    constructor(predicate, source) {\n        this.predicate = predicate;\n        this.source = source;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));\n    }\n}\nclass SingleSubscriber extends Subscriber {\n    constructor(destination, predicate, source) {\n        super(destination);\n        this.predicate = predicate;\n        this.source = source;\n        this.seenValue = false;\n        this.index = 0;\n    }\n    applySingleValue(value) {\n        if (this.seenValue) {\n            this.destination.error('Sequence contains more than one element');\n        }\n        else {\n            this.seenValue = true;\n            this.singleValue = value;\n        }\n    }\n    _next(value) {\n        const index = this.index++;\n        if (this.predicate) {\n            this.tryNext(value, index);\n        }\n        else {\n            this.applySingleValue(value);\n        }\n    }\n    tryNext(value, index) {\n        try {\n            if (this.predicate(value, index, this.source)) {\n                this.applySingleValue(value);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    }\n    _complete() {\n        const destination = this.destination;\n        if (this.index > 0) {\n            destination.next(this.seenValue ? this.singleValue : undefined);\n            destination.complete();\n        }\n        else {\n            destination.error(new EmptyError);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}