{"ast":null,"code":"import { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\nexport function expand(project, concurrent = Number.POSITIVE_INFINITY, scheduler) {\n  concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;\n  return source => source.lift(new ExpandOperator(project, concurrent, scheduler));\n}\nexport class ExpandOperator {\n  constructor(project, concurrent, scheduler) {\n    this.project = project;\n    this.concurrent = concurrent;\n    this.scheduler = scheduler;\n  }\n\n  call(subscriber, source) {\n    return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));\n  }\n\n}\nexport class ExpandSubscriber extends SimpleOuterSubscriber {\n  constructor(destination, project, concurrent, scheduler) {\n    super(destination);\n    this.project = project;\n    this.concurrent = concurrent;\n    this.scheduler = scheduler;\n    this.index = 0;\n    this.active = 0;\n    this.hasCompleted = false;\n\n    if (concurrent < Number.POSITIVE_INFINITY) {\n      this.buffer = [];\n    }\n  }\n\n  static dispatch(arg) {\n    const {\n      subscriber,\n      result,\n      value,\n      index\n    } = arg;\n    subscriber.subscribeToProjection(result, value, index);\n  }\n\n  _next(value) {\n    const destination = this.destination;\n\n    if (destination.closed) {\n      this._complete();\n\n      return;\n    }\n\n    const index = this.index++;\n\n    if (this.active < this.concurrent) {\n      destination.next(value);\n\n      try {\n        const {\n          project\n        } = this;\n        const result = project(value, index);\n\n        if (!this.scheduler) {\n          this.subscribeToProjection(result, value, index);\n        } else {\n          const state = {\n            subscriber: this,\n            result,\n            value,\n            index\n          };\n          const destination = this.destination;\n          destination.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));\n        }\n      } catch (e) {\n        destination.error(e);\n      }\n    } else {\n      this.buffer.push(value);\n    }\n  }\n\n  subscribeToProjection(result, value, index) {\n    this.active++;\n    const destination = this.destination;\n    destination.add(innerSubscribe(result, new SimpleInnerSubscriber(this)));\n  }\n\n  _complete() {\n    this.hasCompleted = true;\n\n    if (this.hasCompleted && this.active === 0) {\n      this.destination.complete();\n    }\n\n    this.unsubscribe();\n  }\n\n  notifyNext(innerValue) {\n    this._next(innerValue);\n  }\n\n  notifyComplete() {\n    const buffer = this.buffer;\n    this.active--;\n\n    if (buffer && buffer.length > 0) {\n      this._next(buffer.shift());\n    }\n\n    if (this.hasCompleted && this.active === 0) {\n      this.destination.complete();\n    }\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Morgan/Desktop/DEV/angular/mbo-ez-angular-ez-http-client/node_modules/rxjs/_esm2015/internal/operators/expand.js"],"names":["SimpleOuterSubscriber","innerSubscribe","SimpleInnerSubscriber","expand","project","concurrent","Number","POSITIVE_INFINITY","scheduler","source","lift","ExpandOperator","constructor","call","subscriber","subscribe","ExpandSubscriber","destination","index","active","hasCompleted","buffer","dispatch","arg","result","value","subscribeToProjection","_next","closed","_complete","next","state","add","schedule","e","error","push","complete","unsubscribe","notifyNext","innerValue","notifyComplete","length","shift"],"mappings":"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","sourcesContent":["import { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\nexport function expand(project, concurrent = Number.POSITIVE_INFINITY, scheduler) {\n    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;\n    return (source) => source.lift(new ExpandOperator(project, concurrent, scheduler));\n}\nexport class ExpandOperator {\n    constructor(project, concurrent, scheduler) {\n        this.project = project;\n        this.concurrent = concurrent;\n        this.scheduler = scheduler;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));\n    }\n}\nexport class ExpandSubscriber extends SimpleOuterSubscriber {\n    constructor(destination, project, concurrent, scheduler) {\n        super(destination);\n        this.project = project;\n        this.concurrent = concurrent;\n        this.scheduler = scheduler;\n        this.index = 0;\n        this.active = 0;\n        this.hasCompleted = false;\n        if (concurrent < Number.POSITIVE_INFINITY) {\n            this.buffer = [];\n        }\n    }\n    static dispatch(arg) {\n        const { subscriber, result, value, index } = arg;\n        subscriber.subscribeToProjection(result, value, index);\n    }\n    _next(value) {\n        const destination = this.destination;\n        if (destination.closed) {\n            this._complete();\n            return;\n        }\n        const index = this.index++;\n        if (this.active < this.concurrent) {\n            destination.next(value);\n            try {\n                const { project } = this;\n                const result = project(value, index);\n                if (!this.scheduler) {\n                    this.subscribeToProjection(result, value, index);\n                }\n                else {\n                    const state = { subscriber: this, result, value, index };\n                    const destination = this.destination;\n                    destination.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));\n                }\n            }\n            catch (e) {\n                destination.error(e);\n            }\n        }\n        else {\n            this.buffer.push(value);\n        }\n    }\n    subscribeToProjection(result, value, index) {\n        this.active++;\n        const destination = this.destination;\n        destination.add(innerSubscribe(result, new SimpleInnerSubscriber(this)));\n    }\n    _complete() {\n        this.hasCompleted = true;\n        if (this.hasCompleted && this.active === 0) {\n            this.destination.complete();\n        }\n        this.unsubscribe();\n    }\n    notifyNext(innerValue) {\n        this._next(innerValue);\n    }\n    notifyComplete() {\n        const buffer = this.buffer;\n        this.active--;\n        if (buffer && buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        if (this.hasCompleted && this.active === 0) {\n            this.destination.complete();\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}