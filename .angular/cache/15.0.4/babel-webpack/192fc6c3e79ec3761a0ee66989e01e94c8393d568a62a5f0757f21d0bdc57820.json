{"ast":null,"code":"import { Subject } from '../Subject';\nimport { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { isNumeric } from '../util/isNumeric';\nimport { isScheduler } from '../util/isScheduler';\nexport function windowTime(windowTimeSpan) {\n  let scheduler = async;\n  let windowCreationInterval = null;\n  let maxWindowSize = Number.POSITIVE_INFINITY;\n\n  if (isScheduler(arguments[3])) {\n    scheduler = arguments[3];\n  }\n\n  if (isScheduler(arguments[2])) {\n    scheduler = arguments[2];\n  } else if (isNumeric(arguments[2])) {\n    maxWindowSize = Number(arguments[2]);\n  }\n\n  if (isScheduler(arguments[1])) {\n    scheduler = arguments[1];\n  } else if (isNumeric(arguments[1])) {\n    windowCreationInterval = Number(arguments[1]);\n  }\n\n  return function windowTimeOperatorFunction(source) {\n    return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));\n  };\n}\n\nclass WindowTimeOperator {\n  constructor(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n    this.windowTimeSpan = windowTimeSpan;\n    this.windowCreationInterval = windowCreationInterval;\n    this.maxWindowSize = maxWindowSize;\n    this.scheduler = scheduler;\n  }\n\n  call(subscriber, source) {\n    return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));\n  }\n\n}\n\nclass CountedSubject extends Subject {\n  constructor() {\n    super(...arguments);\n    this._numberOfNextedValues = 0;\n  }\n\n  next(value) {\n    this._numberOfNextedValues++;\n    super.next(value);\n  }\n\n  get numberOfNextedValues() {\n    return this._numberOfNextedValues;\n  }\n\n}\n\nclass WindowTimeSubscriber extends Subscriber {\n  constructor(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n    super(destination);\n    this.destination = destination;\n    this.windowTimeSpan = windowTimeSpan;\n    this.windowCreationInterval = windowCreationInterval;\n    this.maxWindowSize = maxWindowSize;\n    this.scheduler = scheduler;\n    this.windows = [];\n    const window = this.openWindow();\n\n    if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n      const closeState = {\n        subscriber: this,\n        window,\n        context: null\n      };\n      const creationState = {\n        windowTimeSpan,\n        windowCreationInterval,\n        subscriber: this,\n        scheduler\n      };\n      this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));\n      this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));\n    } else {\n      const timeSpanOnlyState = {\n        subscriber: this,\n        window,\n        windowTimeSpan\n      };\n      this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));\n    }\n  }\n\n  _next(value) {\n    const windows = this.windows;\n    const len = windows.length;\n\n    for (let i = 0; i < len; i++) {\n      const window = windows[i];\n\n      if (!window.closed) {\n        window.next(value);\n\n        if (window.numberOfNextedValues >= this.maxWindowSize) {\n          this.closeWindow(window);\n        }\n      }\n    }\n  }\n\n  _error(err) {\n    const windows = this.windows;\n\n    while (windows.length > 0) {\n      windows.shift().error(err);\n    }\n\n    this.destination.error(err);\n  }\n\n  _complete() {\n    const windows = this.windows;\n\n    while (windows.length > 0) {\n      const window = windows.shift();\n\n      if (!window.closed) {\n        window.complete();\n      }\n    }\n\n    this.destination.complete();\n  }\n\n  openWindow() {\n    const window = new CountedSubject();\n    this.windows.push(window);\n    const destination = this.destination;\n    destination.next(window);\n    return window;\n  }\n\n  closeWindow(window) {\n    window.complete();\n    const windows = this.windows;\n    windows.splice(windows.indexOf(window), 1);\n  }\n\n}\n\nfunction dispatchWindowTimeSpanOnly(state) {\n  const {\n    subscriber,\n    windowTimeSpan,\n    window\n  } = state;\n\n  if (window) {\n    subscriber.closeWindow(window);\n  }\n\n  state.window = subscriber.openWindow();\n  this.schedule(state, windowTimeSpan);\n}\n\nfunction dispatchWindowCreation(state) {\n  const {\n    windowTimeSpan,\n    subscriber,\n    scheduler,\n    windowCreationInterval\n  } = state;\n  const window = subscriber.openWindow();\n  const action = this;\n  let context = {\n    action,\n    subscription: null\n  };\n  const timeSpanState = {\n    subscriber,\n    window,\n    context\n  };\n  context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);\n  action.add(context.subscription);\n  action.schedule(state, windowCreationInterval);\n}\n\nfunction dispatchWindowClose(state) {\n  const {\n    subscriber,\n    window,\n    context\n  } = state;\n\n  if (context && context.action && context.subscription) {\n    context.action.remove(context.subscription);\n  }\n\n  subscriber.closeWindow(window);\n}","map":{"version":3,"sources":["C:/Users/Morgan/Desktop/DEV/angular/mbo-ez-angular-ez-http-client/node_modules/rxjs/_esm2015/internal/operators/windowTime.js"],"names":["Subject","async","Subscriber","isNumeric","isScheduler","windowTime","windowTimeSpan","scheduler","windowCreationInterval","maxWindowSize","Number","POSITIVE_INFINITY","arguments","windowTimeOperatorFunction","source","lift","WindowTimeOperator","constructor","call","subscriber","subscribe","WindowTimeSubscriber","CountedSubject","_numberOfNextedValues","next","value","numberOfNextedValues","destination","windows","window","openWindow","closeState","context","creationState","add","schedule","dispatchWindowClose","dispatchWindowCreation","timeSpanOnlyState","dispatchWindowTimeSpanOnly","_next","len","length","i","closed","closeWindow","_error","err","shift","error","_complete","complete","push","splice","indexOf","state","action","subscription","timeSpanState","remove"],"mappings":"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","sourcesContent":["import { Subject } from '../Subject';\nimport { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { isNumeric } from '../util/isNumeric';\nimport { isScheduler } from '../util/isScheduler';\nexport function windowTime(windowTimeSpan) {\n    let scheduler = async;\n    let windowCreationInterval = null;\n    let maxWindowSize = Number.POSITIVE_INFINITY;\n    if (isScheduler(arguments[3])) {\n        scheduler = arguments[3];\n    }\n    if (isScheduler(arguments[2])) {\n        scheduler = arguments[2];\n    }\n    else if (isNumeric(arguments[2])) {\n        maxWindowSize = Number(arguments[2]);\n    }\n    if (isScheduler(arguments[1])) {\n        scheduler = arguments[1];\n    }\n    else if (isNumeric(arguments[1])) {\n        windowCreationInterval = Number(arguments[1]);\n    }\n    return function windowTimeOperatorFunction(source) {\n        return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));\n    };\n}\nclass WindowTimeOperator {\n    constructor(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n        this.windowTimeSpan = windowTimeSpan;\n        this.windowCreationInterval = windowCreationInterval;\n        this.maxWindowSize = maxWindowSize;\n        this.scheduler = scheduler;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));\n    }\n}\nclass CountedSubject extends Subject {\n    constructor() {\n        super(...arguments);\n        this._numberOfNextedValues = 0;\n    }\n    next(value) {\n        this._numberOfNextedValues++;\n        super.next(value);\n    }\n    get numberOfNextedValues() {\n        return this._numberOfNextedValues;\n    }\n}\nclass WindowTimeSubscriber extends Subscriber {\n    constructor(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n        super(destination);\n        this.destination = destination;\n        this.windowTimeSpan = windowTimeSpan;\n        this.windowCreationInterval = windowCreationInterval;\n        this.maxWindowSize = maxWindowSize;\n        this.scheduler = scheduler;\n        this.windows = [];\n        const window = this.openWindow();\n        if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n            const closeState = { subscriber: this, window, context: null };\n            const creationState = { windowTimeSpan, windowCreationInterval, subscriber: this, scheduler };\n            this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));\n            this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));\n        }\n        else {\n            const timeSpanOnlyState = { subscriber: this, window, windowTimeSpan };\n            this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));\n        }\n    }\n    _next(value) {\n        const windows = this.windows;\n        const len = windows.length;\n        for (let i = 0; i < len; i++) {\n            const window = windows[i];\n            if (!window.closed) {\n                window.next(value);\n                if (window.numberOfNextedValues >= this.maxWindowSize) {\n                    this.closeWindow(window);\n                }\n            }\n        }\n    }\n    _error(err) {\n        const windows = this.windows;\n        while (windows.length > 0) {\n            windows.shift().error(err);\n        }\n        this.destination.error(err);\n    }\n    _complete() {\n        const windows = this.windows;\n        while (windows.length > 0) {\n            const window = windows.shift();\n            if (!window.closed) {\n                window.complete();\n            }\n        }\n        this.destination.complete();\n    }\n    openWindow() {\n        const window = new CountedSubject();\n        this.windows.push(window);\n        const destination = this.destination;\n        destination.next(window);\n        return window;\n    }\n    closeWindow(window) {\n        window.complete();\n        const windows = this.windows;\n        windows.splice(windows.indexOf(window), 1);\n    }\n}\nfunction dispatchWindowTimeSpanOnly(state) {\n    const { subscriber, windowTimeSpan, window } = state;\n    if (window) {\n        subscriber.closeWindow(window);\n    }\n    state.window = subscriber.openWindow();\n    this.schedule(state, windowTimeSpan);\n}\nfunction dispatchWindowCreation(state) {\n    const { windowTimeSpan, subscriber, scheduler, windowCreationInterval } = state;\n    const window = subscriber.openWindow();\n    const action = this;\n    let context = { action, subscription: null };\n    const timeSpanState = { subscriber, window, context };\n    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);\n    action.add(context.subscription);\n    action.schedule(state, windowCreationInterval);\n}\nfunction dispatchWindowClose(state) {\n    const { subscriber, window, context } = state;\n    if (context && context.action && context.subscription) {\n        context.action.remove(context.subscription);\n    }\n    subscriber.closeWindow(window);\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}